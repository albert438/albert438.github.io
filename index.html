<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Albert43&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="Albert43's Blog">
<meta property="og:url" content="http://albert438.github.io/index.html">
<meta property="og:site_name" content="Albert43's Blog">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Albert43's Blog">
<meta name="twitter:description">
  
    <link rel="alternative" href="/atom.xml" title="Albert43&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="https://avatars2.githubusercontent.com/u/6995711?v=3&amp;amp;s=460" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Albert43</a></h1>
		</hgroup>

		
		<p class="header-subtitle">学习总结 思考感悟</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
						<li>关于我</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/albert438" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/albert43" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:albertliang.lt@gmail.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/JSPatch/" style="font-size: 15px;">JSPatch</a> <a href="/tags/iOS开发/" style="font-size: 20px;">iOS开发</a> <a href="/tags/小记/" style="font-size: 10px;">小记</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://nianxi.net/">念茜博客</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://blog.cnbang.net/">bang&#39;s blog</a>
			        
			          <a target="_blank" class="main-nav-link switch-friends-link" href="http://www.justinyan.me/">枫言枫语</a>
			        
			        </div>
				</section>
				

				
				
				<section class="switch-part switch-part4">
				
					<div id="js-aboutme">我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Albert43</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="https://avatars2.githubusercontent.com/u/6995711?v=3&amp;amp;s=460" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Albert43</h1>
			</hgroup>
			
			<p class="header-subtitle">学习总结 思考感悟</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/albert438" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/albert43" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:albertliang.lt@gmail.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-JSPatch总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/26/JSPatch总结/" class="article-date">
  	<time datetime="2015-07-26T09:14:20.000Z" itemprop="datePublished">2015-07-26</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/26/JSPatch总结/">JSPatch总结</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JSPatch总结">JSPatch总结</h1><h2 id="目录"><a name="jspatchIntroducton">目录</a></h2><ol>
<li><a href="#jspatchIntroducton"><strong>JSPatch介绍</strong></a></li>
<li><a href="#jspatch-wax"><strong>JSPatch VS Wax lua</strong></a></li>
<li><a href="#jspatch-core"><strong>JSPatch的原理和核心</strong></a></li>
<li><a href="#jspatch-Extension"><strong>JSPatch Extension机制</strong></a></li>
<li><a href="#jspatch-Tech"><strong>JSPatch中的实现技巧总结</strong></a> </li>
<li><a href="#jspatch-problem"><strong>遇到的问题与解决方法</strong></a></li>
<li><a href="#conclusion"><strong>工作总结和未来计划</strong></a></li>
</ol>
<h2 id="一、JSPatch介绍"><a name="jspatchIntroducton">一、JSPatch介绍</a></h2><h3 id="用途">用途</h3><p>iOS产品开发之中常常会遇到这种情况: 新版本上线后发现有个严重的bug，可能会导致crash率激增，可能会使网络请求无法发出，这时能做的只是赶紧修复bug然后提交等待漫长的AppStore审核，再盼望用户快点升级，付出巨大的人力和时间成本，才能完成此次bug的修复。</p>
<p>JSPatch的出现解决了这样的问题，只需要在项目中引入极小的JSPatch引擎，就可以使用JavaScript语言调用Objective-C的原生接口，获得脚本语言的能力：动态更新iOS APP，替换项目原生代码、快速修复bug。      </p>
<h3 id="技术核心">技术核心</h3><p>JSPatch核心主要是JSBinding和Objective-C中的runtime技术。一方面，它采用Apple在iOS7中发布的JavaScriptCore.framework作为Javascript引擎解析JavaScript脚本，执行JavaSript代码并与Objective-C端的代码进行桥接。另一方面则是使用Objective-C runtime中的method swizzling的方式达到使用JavaScript脚本动态替换原有Objective-C方法的目的，并利用ForwardInvocation标准消息转发机制使得在JavaScript脚本中调用Objective-C的方法成为可能。</p>
<h2 id="二、JSPatch_VS_lua_Wax"><a name="jspatch-wax">二、JSPatch VS lua Wax</a></h2><p>wax是可以实现动态打补丁快速修补Crash的另外一种解决方案，初衷是为了使用lua来编写iOS原生应用而诞生的一个框架。它利用lua的C语言API(可以让C代码与lua进行交互的函数集，包括读写lua全局变量的函数，调用lua函数的函数，运行lua代码片段的函数，注册C函数然后可以在lua中被调用的函数，等等)和 Objective-C 强大的runtime使lua能调用原生Objective-C接口，可以使用lua创建，继承，扩展oc类，使用lua实现oc所能实现的所有功能。</p>
<p>lua wax由几个部分组成:</p>
<ol>
<li><p>wax stdLib，是一个lua脚本库，利用前面提到的C API和Objective-C runtime向lua脚本提供与Objective-C类交互的接口;</p>
</li>
<li><p>Wax Engine，提供使用Objective-C加载运行lua脚本和传递变量给lua脚本的接口;</p>
</li>
<li><p>lua Compiler，即lua解释器，wax Engine调用解释器加载并编译运行lua脚本。<br><img src="http://ww1.sinaimg.cn/bmiddle/68e55315gw1eu0af1y3asj20dp0ec3z0.jpg" alt="Wax lua"></p>
</li>
</ol>
<p>相比于wax，    JSPatch有以下的优势</p>
<ol>
<li><p>Javascript比lua在应用开发领域有更广泛的应用。 目前前端开发和终端开发有融合的趋势，作为扩展的脚本语言，JavaScript是不二之选。</p>
</li>
<li><p>更符合Apple的规则。iOS Developer Program License Agreement里3.3.2提到不可动态下发可执行代码，但通过苹果JavaScriptCore.framework或WebKit执行的代码除外，JS正是通过JavaScriptCore.framework执行的。</p>
</li>
<li><p>小巧。 使用系统内置的JavaScriptCore.framework，无需内嵌脚本引擎，体积小巧。而Wax需要导入c代码写的lua引擎。</p>
</li>
<li><p>支持block。<br>wax在几年前就停止了开发和维护，不支持Objective-C里block跟lua程序的互传，虽然一些第三方已经实现block，但使用时参数上也有比较多的限制。</p>
</li>
<li><p>不需要担心内存回收的问题。JavascriptCore.framework通过GC来对垃圾进行回收。而lua wax需要显式调用内存回收方法。</p>
</li>
<li><p>支持armv7 armv7s arm64框架。wax并不支持arm64框架。</p>
</li>
</ol>
<p>而JSPatch也有自身的缺点:</p>
<ol>
<li><p>不支持iOS6及以下，因为JSPatch依赖于iOS7及以后的JavascriptCore.framework (这点现在可以忽略，因为微信最低的版本要求已经是iOS7)</p>
</li>
<li><p>调用OC方法的性能慢于lua wax</p>
</li>
<li><p>启动JSPatch所占用的内存多于wax</p>
</li>
</ol>
<h2 id="三、JSPatch核心原理解析"><a name="jspatch-core">三、JSPatch核心原理解析</a></h2><h3 id="startEngine">startEngine</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">JPEngine</span> startEngine];</span><br><span class="line"><span class="built_in">NSString</span> *sourcePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"demo"</span> ofType:<span class="string">@"js"</span>];</span><br><span class="line"><span class="built_in">NSString</span> *script = [<span class="built_in">NSString</span> stringWithContentsOfFile:sourcePath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">[<span class="built_in">JPEngine</span> evaluateScript:script];</span><br></pre></td></tr></table></figure>
<p>使用JSPatch框架首先要调用<code>JPEngine</code>中的类方法<code>startEngine</code>，这个方法的是为了初始化JSContext，JSContext是JS脚本的运行环境。JS脚本可以调用在JSContext中预先定义的方法，方法的参数/返回值都会被JavaScriptCore.framework自动转换，OC里的NSArray，NSDictionary，NSString，NSNumber，NSBlock，[NSNull null]会分别转为JS端的Array/Object/String/Number/function/null。</p>
<p>那其他无法通过JavascriptCore.framework进行bridge转换的数据类型，比如自定义的类的对象，Class类型，指针，要如何在JS和OC两端进行传递呢？</p>
<p>JSPatch中使用了一个叫做JPBoxing的类去封装id、指针、Class类型变量，封装完以后这个Boxing对象会被放在一个NSDictionary里(NSDictionary可转化为JS中的Object类型)，传递给JS代码。<a href="#jspatch-boxing">后面</a>会对JPBoxing进行详细的介绍.</p>
<p>回到startEngine方法:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">context[<span class="string">@"_OC_defineClass"</span>] = ^(<span class="built_in">NSString</span> *classDeclaration, <span class="built_in">JSValue</span> *instanceMethods, <span class="built_in">JSValue</span> *classMethods) &#123;</span><br><span class="line">        <span class="keyword">return</span> define<span class="built_in">Class</span>(classDeclaration, instanceMethods, classMethods);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">context[<span class="string">@"_OC_callI"</span>] = ^<span class="keyword">id</span>(<span class="built_in">JSValue</span> *obj, <span class="built_in">NSString</span> *selectorName, <span class="built_in">JSValue</span> *arguments, <span class="built_in">BOOL</span> isSuper) &#123;</span><br><span class="line">        <span class="keyword">return</span> callSelector(<span class="literal">nil</span>, selectorName, arguments, obj, isSuper);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">context[<span class="string">@"_OC_callC"</span>] = ^<span class="keyword">id</span>(<span class="built_in">NSString</span> *className, <span class="built_in">NSString</span> *selectorName, <span class="built_in">JSValue</span> *arguments) &#123;</span><br><span class="line">        <span class="keyword">return</span> callSelector(className, selectorName, arguments, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在这里定义的函数主要是负责处理转换从JS端传过来的参数，然后在OC端运用runtime里的方法实现生成新的类、替换旧的类、调用方法等等功能。</p>
<p>其中<code>_OC_defineClass</code>负责定义新的类或替换原有的类，<code>_OC_callI</code>负责调用实例方法，<code>_OC_callC</code>负责调用类方法。</p>
<p>除了这三个函数之外，startEngine中还封装了一些常用GCD方法、console.log、sizeof、Javascript异常捕获函数等等。</p>
<p>准备完JSContext之后，就可以加载从网络中下载的JS补丁，调用<code>[JPEngeine evaluateScript:script]</code>方法执行脚本。</p>
<h3 id="defineClass">defineClass</h3><p>接下来讲解JSPatch中如何定义一个类以及怎么覆盖原方法或新增一个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defineClass(<span class="string">'JPViewController'</span>, &#123;</span><br><span class="line">  handleBtn: <span class="function"><span class="keyword">function</span>(<span class="params">sender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tableViewCtrl = JPTableViewController.alloc().init()</span><br><span class="line">    self.navigationController().pushViewController_animated(tableViewCtrl, YES)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></figure>
<p><code>defineClass</code>函数可接受三个参数：</p>
<ol>
<li>字符串:”需要替换或者新增的类名:继承的父类名 &lt;实现的协议1，实现的协议2&gt;”</li>
<li>{实例方法}</li>
<li>{类方法}</li>
</ol>
<p>将这三个参数通过bridging传入到OC后，执行以下步骤:</p>
<ol>
<li>使用NSScanner分离classDeclaration，分离成三部分<ul>
<li>类名 : className</li>
<li>父类名 : superClassName</li>
<li>实现的协议名 : protocalNames</li>
</ul>
</li>
<li>使用NSClassFromString(className)获得该Class对象。<ul>
<li>若该Class对象为nil，则说明JS端要添加一个新的类，使用<code>objc_allocateClassPair</code>与<code>objc_registerClassPair</code>注册一个新的类。</li>
<li>若该Class对象不为nil，则说明JS端要替换一个原本已存在的类</li>
</ul>
</li>
<li>根据从JS端传递来的实例方法与类方法参数，为这个类对象添加/替换实例方法与类方法<ul>
<li>添加实例方法时，直接使用上一步得到class对象; 添加类方法时需要调用<code>objc_getMetaClass</code>方法获得元类。</li>
<li>如果要替换的类已经定义了该方法，则直接对该方法替换和实现消息转发。</li>
<li>否则根据以下两种情况进行判断<ul>
<li>遍历protocalNames，通过<code>objc_getProtocol</code>方法获得协议对象，再使用<code>protocol_copyMethodDescriptionList</code>来获得协议中方法的type和name。匹配JS中传入的selectorName，获得typeDescription字符串，对该协议方法的实现消息转发。</li>
<li>若不是上述两种情况，则js端请求添加一个新的方法。构造一个typeDescription为”@@:\@*”(返回类型为id，参数值根据JS定义的参数个数来决定。新增方法的返回类型和参数类型只能为id类型，因为在JS端只能定义对象)的IMP。将这个IMP添加到类中。</li>
</ul>
</li>
</ul>
</li>
<li>为该类添加<code>setProp:forKey</code>和<code>getProp:</code>方法，使用<code>objc_getAssociatedObject</code>与<code>objc_setAssociatedObject</code>让JS脚本拥有设置property的能力</li>
<li>返回{className:cls}回JS脚本。</li>
</ol>
<h3 id="overrideMethod方法">overrideMethod方法</h3><p>不管是替换方法还是新增方法，都是使用<code>overrideMethod</code>方法。<br>它接受五个参数:</p>
<ul>
<li>类名</li>
<li>要替换的方法名</li>
<li>JS中定义的方法</li>
<li>是否类方法</li>
<li>方法的typeDescription</li>
</ul>
<p>原型如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> overrideMethod(<span class="built_in">Class</span> cls, <span class="built_in">NSString</span> *selectorName, <span class="built_in">JSValue</span> *function, <span class="built_in">BOOL</span> is<span class="built_in">ClassMethod</span>, <span class="keyword">const</span> <span class="keyword">char</span> *typeDescription)</span><br></pre></td></tr></table></figure>
<p>逻辑步骤如下</p>
<ol>
<li>初始化：更具selectorName获取对应的Selector；typeDescription获得NSMethodSignature方法签名。</li>
<li>保存原有方法的IMP，添加名为<code>@&quot;ORIG&quot; + selectorName</code>的方法，IMP为原方法的IMP。</li>
<li>将原方法的IMP设置为消息转发<ul>
<li>若该方法的返回值为特殊的struct类型，则需要将IMP设置为<code>(IMP)_objc_msgForward_stret</code></li>
<li>否则的话将IMP设置为<code>_objc_msgForward</code></li>
</ul>
</li>
<li>保存原有转发方法<code>forwardInvocation:</code>的IMP，添加selectorName为@”ORIGforwardInvocation:”，IMP为原转发方法IMP的方法。</li>
<li>将原转发方法替换为自己的转发方法<code>JPForwardInvocation</code></li>
<li>根据替换/添加方法的返回类型，选择不同的替换IMP(使用宏的形式定义)，替换原方法。</li>
</ol>
<h3 id="callSelector方法">callSelector方法</h3><p>在JS端调用OC方法时，都需要通过在OC端通过<code>callSelector</code>方法进行方法的查找以及参数类型、返回类型的转换和处理。</p>
<p>该方法接受五个参数</p>
<ul>
<li>调用对象的类名</li>
<li>被调用的selectorName</li>
<li>JS中传递过来的参数</li>
<li>JS端封装的实例对象</li>
<li>是否调用的是super类的方法</li>
</ul>
<p>方法的原型：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> callSelector(<span class="built_in">NSString</span> *className, <span class="built_in">NSString</span> *selectorName, <span class="built_in">JSValue</span> *arguments, <span class="built_in">JSValue</span> *instance, <span class="built_in">BOOL</span> isSuper)</span><br></pre></td></tr></table></figure>
<p>逻辑步骤如下</p>
<ol>
<li>初始化<ul>
<li>将JS封装的instance对象进行拆装，得到OC的对象；</li>
<li>根据类名与selectorName获得对应的类对象与selector；</li>
<li>通过类对象与selector构造对应的NSMethodSignature签名，再根据签名构造NSInvocation对象，并为invocation对象设置target与Selector</li>
</ul>
</li>
<li>根据方法签名，获悉方法每个参数的实际类型，将JS传递过来的参数进行对应的转换(比如说参数的实际类型为int类型，但是JS只能传递NSNumber对象，需要通过<code>[[jsObj toNumber] intValue]</code>进行转换)。转换后使用<code>setArgument方法</code>为NSInvocation对象设置参数。</li>
<li>执行invoke方法。</li>
<li>通过getReturnValue方法获取到返回值。</li>
<li>根据返回值类型，封装成JS中对应的对象(因为JS并不识别OC对象，所以返回值为OC对象的话需封装成{<strong>className:className, </strong>obj:obj})返回给JS端。</li>
</ol>
<h3 id="JPForwardInvocation方法">JPForwardInvocation方法</h3><p>JPForwardInvocation方法替换了原有<code>-forwardInvocation</code>方法的实现，使得消息转发都通过该方法，并将消息转发给JS脚本中定义的方法，通过JavascriptCore.frameWork中提供的<code>callWithArguments</code>方法调用JS方法达到替换原方法，添加新方法的目的。是实现替换和新增方法的核心。</p>
<p>它的原型与ForwardInvocation方法相同</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="built_in">JPForwardInvocation</span>(<span class="keyword">id</span> slf, <span class="built_in">SEL</span> selector, <span class="built_in">NSInvocation</span> *invocation)</span><br></pre></td></tr></table></figure>
<p>它的内部逻辑并不复杂，主要是读取出传入的invocation对象中的所有参数，根据实际参数的类型将JSValue类型的参数转换成对应的OC类型，最后将参数添加到_TMPInvocationArguments数组以供JS调用。</p>
<p>那如果有一些类确实有用到这个方法进行消息转发（比如为了实现多继承），那原来的逻辑该怎么办？ </p>
<p>JSPatch在替换<code>-forwardInvocation:</code>方法前会新建一个方法<code>-ORIGforwardInvocation:</code>，保存原来的实现IMP，在新的<code>-forwardInvocation:</code>实现里做了个判断，如果转发的方法是JS脚本中想改写的，就走<code>-JPForwardInvocation:</code>逻辑，若不是，就调用<code>-ORIGforwardInvocation:</code>走原来的流程。</p>
<h3 id="对象的持有/转换"><a name="jspatch-convert"></a>对象的持有/转换</h3><p>原作者bang在<a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">他的博文中</a>，有较为详细的说明。下面引用了他文章中关于对象持有/转换的细节.</p>
<blockquote>
<p>UIView.alloc() 通过上述消息传递后会到OC执行 [UIView alloc]，并返回一个UIView实例对象给JS，这个OC实例对象在JS是怎样表示的呢？怎样可以在JS拿到这个实例对象后可以直接调用它的实例方法 (UIView.alloc().init())？</p>
<p>对于一个自定义id对象，JavaScriptCore会把这个自定义对象的指针传给JS，这个对象在JS无法使用，但在回传给OC时OC可以找到这个对象。对于这个对象生命周期的管理，按我的理解如果JS有变量引用时，这个OC对象引用计数就加1 ，JS变量的引用释放了就减1，如果OC上没别的持有者，这个OC对象的生命周期就跟着JS走了，会在JS进行垃圾回收时释放。<br>传回给JS的变量是这个OC对象的指针，如果不经过任何处理，是无法通过这个变量去调用实例方法的。所以在返回对象时，JSPatch会对这个对象进行封装。</p>
<p>首先，告诉JS这是一个OC对象：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSDictionary</span> *to<span class="built_in">JSObj</span>(<span class="keyword">id</span> obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj) <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">return</span> @&#123;<span class="string">@"__isObj"</span>: @(<span class="literal">YES</span>), <span class="string">@"cls"</span>: <span class="built_in">NSStringFromClass</span>([obj class]), <span class="string">@"obj"</span>: obj&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用__isObj表示这是一个OC对象，对象指针也一起返回。接着在JS端会把这个对象转为一个 JSClass 实例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var _formatOCTo<span class="built_in">JS</span> = function(obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj === undefined || obj === null) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> obj == <span class="string">"object"</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj<span class="variable">.__obj</span>) <span class="keyword">return</span> obj</span><br><span class="line">      <span class="keyword">if</span> (obj<span class="variable">.__isNull</span>) <span class="keyword">return</span> <span class="literal">false</span>  <span class="comment">//注:这里是为了让JS能够链式调用</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj instanceof Array) &#123;</span><br><span class="line">      var ret = []</span><br><span class="line">      obj<span class="variable">.forEach</span>(function(o) &#123;</span><br><span class="line">        ret<span class="variable">.push</span>(_formatOCTo<span class="built_in">JS</span>(o))</span><br><span class="line">      &#125;)</span><br><span class="line">      <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj instanceof Function) &#123;</span><br><span class="line">      <span class="keyword">return</span> function() &#123;</span><br><span class="line">        var args = Array<span class="variable">.prototype</span><span class="variable">.slice</span><span class="variable">.call</span>(arguments)</span><br><span class="line">        <span class="keyword">return</span> obj<span class="variable">.apply</span>(obj，_OC_format<span class="built_in">JSToOC</span>(args))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj instanceof Object) &#123;</span><br><span class="line">      var ret = &#123;&#125;</span><br><span class="line">      <span class="keyword">for</span> (var key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        ret[key] = _formatOCTo<span class="built_in">JS</span>(obj[key])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> ret</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>接着看看对象是怎样回传给OC的。上述例子中，view.setBackgroundColor(require(‘UIColor’).grayColor())，这里生成了一个 UIColor 实例对象，并作为参数回传给OC。根据上面说的，这个 UIColor 实例在JS中的表示是一个 JSClass 实例，所以不能直接回传给OC，这里的参数实际上会在 <strong>c 函数进行处理，会把对象的 .</strong>obj 原指针回传给OC。</p>
</blockquote>
<p>整个对象的持有/转换的流程图如下:</p>
<p><img src="http://blog.cnbang.net/wp-content/uploads/2015/06/JSPatch1.png" alt="convertpng"></p>
<h2 id="四、JSPatch_Extension机制"><a name="jspatch-Extension">四、JSPatch Extension机制</a></h2><h3 id="如何在JSPatch中预定义C_API供JS调用">如何在JSPatch中预定义C API供JS调用</h3><p>上面已经介绍过JSPatch是运用Objective-C runtime和JSBinding技术来在JS中调用Objective-C的方法，但是C API是没法通过runtime技术来获取的。一开始的时候我想使用<code>dlsym</code>函数通过函数名来获取对应的函数指针，通过JS脚本传入C函数的函数名来进行函数调用。但实际上还需要预先定义一个相同类型的函数指针才能调用，做不到完全的动态调用。而且还有一个问题就是像CGRectMake这种，实质上是内联函数，并没有对应的函数地址。更关键的是，没有办法获取C函数的签名，而JS中调用函数是没有具体类型的，传递到OC是以JSValue对象的形式，必须通过转换才能调用对应的C函数。最后的解决方法便是预先在JSContext中提供JS方法和C函数的桥接方法。</p>
<p>这里以定义CGRectMake()来作为例子，如果想在JS中使用CGRectMake()函数，则需要在JPEngine启动的时候，将CGRectMake预定义在JSContext之中。</p>
<p>而且有一点要注意的，CGRectMake返回的并不是一个对象，而是一个struct类型的变量。struct类型是无法返回到JS环境的，所以要转换成NSDictionary的形式。</p>
<p>Extension中需要定义对应的方法来将struct转换成NSDictionary</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span> *)dictOfStruct:(<span class="keyword">void</span> *)structData typeString:(<span class="keyword">const</span> <span class="keyword">char</span>*)type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (strcmp(type，@encode(<span class="built_in">CGRect</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">CGRect</span> *rect = structData;</span><br><span class="line">        <span class="keyword">return</span> @&#123;<span class="string">@"x"</span>: @(rect-&gt;origin<span class="variable">.x</span>), <span class="string">@"y"</span>: @(rect-&gt;origin<span class="variable">.y</span>), <span class="string">@"width"</span>: @(rect-&gt;size<span class="variable">.width</span>)，<span class="string">@"height"</span>: @(rect-&gt;size<span class="variable">.height</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面接着定义其他类型的Struct</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以在startEngine中定义CGRectMake方法了，具体如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context[<span class="string">@"CGRectMake"</span>] = ^<span class="keyword">id</span>(<span class="built_in">JSValue</span> *x，<span class="built_in">JSValue</span> *y，<span class="built_in">JSValue</span> *width，<span class="built_in">JSValue</span> *height)&#123;</span><br><span class="line">        <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>([x toDouble], [y toDouble], [width toDouble], [height toDouble]);</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">JPEngine</span> dictOfStruct:&amp;rect typeString:@encode(<span class="built_in">CGRect</span>)];</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在JS中就可以如此调用桥接函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frame = CGRectMake(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>
<p><a name="jspatch-boxing"></a>但是如果返回的值是一个<strong>指针或者参数值为指针</strong>要如何解决？</p>
<p>这时候就需要一个Boxing对象对指针和Class这些在JS中无法使用的变量类型进行装箱(box);在JS中调用OC或C方法后，传递回到Objective-C端的再进行拆箱(unbox)。</p>
<p>Boxing对象的定义如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">JPBoxing</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">id</span> obj;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="keyword">void</span> *pointer;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">Class</span> cls;</span><br><span class="line">- (<span class="keyword">id</span>)unbox;</span><br><span class="line">- (<span class="keyword">void</span> *)unboxPointer;</span><br><span class="line">- (<span class="built_in">Class</span>)unbox<span class="built_in">Class</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">JPBoxing</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define JPBOXING_GEN(_name, _prop, _type) \</span></span><br><span class="line">+ (instancetype)_name:(_type)obj  \</span><br><span class="line">&#123;   \</span><br><span class="line">    <span class="built_in">JPBoxing</span> *boxing = [[<span class="built_in">JPBoxing</span> alloc] init]; \</span><br><span class="line">    boxing<span class="variable">._prop</span> = obj;   \</span><br><span class="line">    <span class="keyword">return</span> boxing;  \</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">JPBOXING_GEN</span>(boxObj, obj, <span class="keyword">id</span>)</span><br><span class="line"><span class="built_in">JPBOXING_GEN</span>(boxPointer, pointer, <span class="keyword">void</span> *)</span><br><span class="line"><span class="built_in">JPBOXING_GEN</span>(box<span class="built_in">Class</span>, cls, <span class="built_in">Class</span>)</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">id</span>)unbox</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span><span class="variable">.obj</span>) <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.obj</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span> *)unboxPointer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.pointer</span>;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">Class</span>)unbox<span class="built_in">Class</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span><span class="variable">.cls</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意到unbox里的一个<code>return self</code>的写法，这里是一个trick。因为前面介绍到的<code>formatJSToOC</code>函数的定义如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">id <span class="title">formatJSToOC</span><span class="params">(JSValue *jsval)</span></span></span><br></pre></td></tr></table></figure>
<p>这个函数需要负责处理JS到OC端的类型转换，但是如果变量类型是指针或者Class类型的话就和无法和id类型写在同一个处理函数里。所以如果是JPBoxing中的obj为nil，则说明是非id类型，直接返回这个JPBoxing。外部得到的这个JPBoxing对象，则再进行相应类型拆箱。</p>
</blockquote>
<p>使用这个Boxing类，调用Extension中的C API时，对指针拆箱，再调用实际的C方法; 返回时，对JS中无法使用的类型进行装箱后再返回; 根据这个机制便可实现对大部分C API的封装。下面以<code>UIGraphicsGetCurrentContext()</code>为例:</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/68e55315gw1eu0bbdxplrj20e5026mxg.jpg" alt="jpboxing1"><br><img src="http://ww4.sinaimg.cn/mw1024/68e55315gw1eu0bb95xx3j20ez0aa75n.jpg" alt="jpboxing2"></p>
<p>效果如下：</p>
<p><img src="http://ww1.sinaimg.cn/mw1024/68e55315gw1eu0bb1sjvsj208w0geaa7.jpg" alt="jpboxing3"></p>
<h3 id="使用JPExtesnion扩展机制对C_API和Struct进行扩展">使用JPExtesnion扩展机制对C API和Struct进行扩展</h3><p>在上一节，我对如何在JSPatch中调用C API进行了介绍。 但是面对大量的C API，需要一个满足以下需求的扩展机制：</p>
<ol>
<li>可模块化加载</li>
<li>js脚本可动态加载</li>
<li>可以在extension中添加struct类型</li>
</ol>
<p>以下是JPExtension协议的定义，所有的C API扩展都需要继承JPExtension协议</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">JPExtensionProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)main:(<span class="built_in">JSContext</span> *)context;</span><br><span class="line"></span><br><span class="line">- (size_t)sizeOfStructWithTypeName:(<span class="built_in">NSString</span> *)typeName;</span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)dictOfStruct:(<span class="keyword">void</span> *)structData typeName:(<span class="built_in">NSString</span> *)typeName;</span><br><span class="line">- (<span class="keyword">void</span>)structData:(<span class="keyword">void</span> *)structData ofDict:(<span class="built_in">NSDictionary</span> *)dict typeName:(<span class="built_in">NSString</span> *)typeName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>开发者可在<code>- (void)main:(JSContext *)context</code>中添加C API，C API会被添加到JS所在的执行环境中。而后面的三个方法从方法名可以知道，extension中如果要定义struct的话则需要实现这三个方法。因为JS中是无法定义和使用c struct的，所以需要提供相应的互相转换方法(struct与NSDictionary互相转换)，具体实现以<code>CGAffineTransform</code>为例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (size_t)sizeOfStructWithTypeName:(<span class="built_in">NSString</span> *)typeName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([typeName rangeOfString:<span class="string">@"CGAffineTransform"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="built_in">CGAffineTransform</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)dictOfStruct:(<span class="keyword">void</span> *)structData typeName:(<span class="built_in">NSString</span> *)typeName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([typeName rangeOfString:<span class="string">@"CGAffineTransform"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="built_in">CGAffineTransform</span> *trans = (<span class="built_in">CGAffineTransform</span> *)structData;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">JPCGTransform</span> transDictOfStruct:trans];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)structData:(<span class="keyword">void</span> *)structData ofDict:(<span class="built_in">NSDictionary</span> *)dict typeName:(<span class="built_in">NSString</span> *)typeName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([typeName rangeOfString:<span class="string">@"CGAffineTransform"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        [<span class="built_in">JPCGTransform</span> transStruct:structData ofDict:dict];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了这三个方法后，JPEngine会将实现了这三个方法extesnion放入_structExtension内。当在JS中调用含有相关struct的方法时，JSEngine会遍历整个_structExtension，找到相应的转换方法。</p>
<p>根据JPExtension协议，模块化加载就变得非常简单：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main:(<span class="built_in">JSContext</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *extensionArray = @[[<span class="built_in">JPCGTransform</span> instance], [<span class="built_in">JPCGContext</span> instance], </span><br><span class="line">                                            [<span class="built_in">JPCGGeometry</span> instance], [<span class="built_in">JPCGBitmapContext</span> instance], </span><br><span class="line">                                            [<span class="built_in">JPCGColor</span> instance], [<span class="built_in">JPCGImage</span> instance], [<span class="built_in">JPCGPath</span> instance]];</span><br><span class="line">    [<span class="built_in">JPEngine</span> addExtensions:extensionArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JS脚本则可以这样调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> extensionArr = [<span class="built_in">require</span>(<span class="string">'JPCoreGraphics'</span>).instance(), <span class="built_in">require</span>(<span class="string">'JPUIKit'</span>).instance()]</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'JPEngine'</span>).addExtensions(extensionArr)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>当然，为了提高项目的性能，你也可以只调用你需要的模块。</p>
<h3 id="C_API定义时需要注意的问题">C API定义时需要注意的问题</h3><p>C API中，有大量的参数或者是返回类型都是指针，包括像CGContextRef这种也是指针，而OC对象在JS环境中也是无法使用的。上面的章节已经提到了从OC端返回给JS端时必须用一个封装对象(JPBoxing)来将指针和对象封装起来。JPExtension提供了以下API来封装OC中的对象和指针成JPBoxing和将JPBoxing对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span> *)formatPointer<span class="built_in">JSToOC</span>:(<span class="built_in">JSValue</span> *)val;</span><br><span class="line">- (<span class="keyword">id</span>)formatPointerOCTo<span class="built_in">JS</span>:(<span class="keyword">void</span> *)pointer;</span><br><span class="line">- (<span class="keyword">id</span>)format<span class="built_in">JSToOC</span>:(<span class="built_in">JSValue</span> *)val;</span><br><span class="line">- (<span class="keyword">id</span>)formatOCTo<span class="built_in">JS</span>:(<span class="keyword">id</span>)obj;</span><br></pre></td></tr></table></figure>
<p>C API封装实例:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">context[<span class="string">@"UIGraphicsGetCurrentContext"</span>] = ^<span class="keyword">id</span>() &#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> c = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> formatPointerOCTo<span class="built_in">JS</span>:c];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">context[<span class="string">@"UIGraphicsBeginImageContext"</span>] = ^<span class="keyword">void</span>(<span class="built_in">NSDictionary</span> *sizeDict) &#123;</span><br><span class="line">        <span class="built_in">CGSize</span> size;</span><br><span class="line">        [<span class="built_in">JPCGGeometry</span> sizeStruct:&amp;size ofDict:sizeDict];</span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>注意到<code>UIGraphicsGetCurrentContext()</code>中返回的是一个CGContextRef类型，所以添加这个扩展API的时候需要将返回类型改为id类型，并将CGContextRef指针封装在JPBoxing中。而<code>UIGraphicsBeginImageContext()</code>需要的是一个CGSize参数，这时候需要在JS端传入一个<code>{x:100, y:100}</code>的Javascript object，这个object会在OC中被转换为NSDictionary.</p>
<p>C API的返回值也需要判断返回值的类型来进行不同的封装，当返回的结果是JavascriptCore.Framework所不支持转换的类型(NSArray，NSDictionary，NSString，NSNumber，NSBlock)，则需要通过<code>formatOCToJS:</code>方法来封装返回。而且返回类型是NSArray，NSDictionary，NSString时，如果你直接返回，JavascriptCore会将返回值转换为JS中的Array，Object，String，你就无法再使用OC的方法。如果你想在JS中使用这三种类型的方法，也需要用<code>formatOCToJS:</code>方法进行封装。</p>
<h3 id="在JSPatch中的操作内存与&amp;取地址运算符">在JSPatch中的操作内存与&amp;取地址运算符</h3><p>与C语言不同，Javascript不能显式的声明一个指向某块内存的指针，也没有<code>&amp;</code>取地址运算符，Javascript是根据参数是引用类型还是基本类型决定传递引用还是传参。但是指针与取地址在C语言以及OC中都会时常被用到。比如如下的情况:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="built_in">NSString</span> *str = <span class="string">@"littleliang"</span>;</span><br><span class="line">[invocation setArgument:&amp;str atIndex:<span class="number">2</span>];</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>JPMemory扩展解决了这个问题，其中封装了内存操作中常用的一些常用的c函数。包括<code>malloc</code>，<code>memset</code>，<code>free</code>，<code>memcpy</code>，<code>memncpy</code>，<code>memmove</code>。</p>
<p>而对<code>&amp;</code>取地址运算符，JPMemory扩展也进行了函数封装，在JS补丁中可以对调用<code>getpointer</code>方法获取对象的指针、指针的指针，针对上述的代码，现在便可以以以下的形式调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="keyword">var</span> str = <span class="built_in">require</span>(<span class="string">'NSString'</span>).stringWithString(<span class="string">'littleliang'</span>)</span><br><span class="line">invocation.setArgument_atIndex(getpointer(str)，<span class="number">2</span>)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>getpointer的底层源码如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span> *)getPointerFrom<span class="built_in">JS</span>:(<span class="built_in">JSValue</span> *)val</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">void</span> **p = malloc(<span class="keyword">sizeof</span>(<span class="keyword">void</span> *));</span><br><span class="line">    <span class="keyword">if</span> ([[val toObject] isKindOf<span class="built_in">Class</span>:[<span class="built_in">NSDictionary</span> class]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[val toObject][<span class="string">@"__obj"</span>] isKindOf<span class="built_in">Class</span>:[<span class="built_in">JPBoxing</span> class]]) &#123;</span><br><span class="line">            <span class="keyword">void</span> *pointer = [(<span class="built_in">JPBoxing</span> *)[val toObject][<span class="string">@"__obj"</span>] unboxPointer];</span><br><span class="line">            <span class="keyword">if</span> (pointer != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *p = pointer;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">id</span> jpobj = [(<span class="built_in">JPBoxing</span> *)[val toObject][<span class="string">@"__obj"</span>] unbox];</span><br><span class="line">                *p = (__bridge <span class="keyword">void</span> *)jpobj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">id</span> obj = [val toObject][<span class="string">@"__obj"</span>];</span><br><span class="line">            *p     = (__bridge <span class="keyword">void</span> *)obj;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"getpointer only support pointer and id type!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而通过JPMemory中的pval或添加pvalWithXXX便可获得指针所指的对象或XXX类型的变量。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> context[<span class="string">@"pval"</span>]    = ^<span class="keyword">id</span>(<span class="built_in">JSValue</span> *jsVal) &#123;</span><br><span class="line">        <span class="keyword">void</span> *m = [<span class="keyword">self</span> formatPointer<span class="built_in">JSToOC</span>:jsVal];</span><br><span class="line">        <span class="keyword">id</span> obj = *((__unsafe_unretained <span class="keyword">id</span> *)m);</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> formatOCTo<span class="built_in">JS</span>:obj];</span><br><span class="line">    &#125;;</span><br><span class="line">   </span><br><span class="line">context[<span class="string">@"pvalWithBool"</span>] = ^<span class="keyword">id</span>(<span class="built_in">JSValue</span> *jsVal) &#123;</span><br><span class="line">        <span class="keyword">void</span> *m = [<span class="keyword">self</span> formatPointer<span class="built_in">JSToOC</span>:jsVal];</span><br><span class="line">        <span class="built_in">BOOL</span> b = *((<span class="built_in">BOOL</span> *)m);</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> formatOCTo<span class="built_in">JS</span>:[<span class="built_in">NSNumber</span> numberWithBool:b]];</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="include函数">include函数</h3><p>在JSPatch最新的更新中，支持了在JS中调用include方法。可以在一个JS文件中加载其他JS文件，包括补丁脚本、第三方脚本。</p>
<p>使用方法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> extensionArr = [<span class="built_in">require</span>(<span class="string">'JPInclude'</span>).instance()]</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'JPEngine'</span>).addExtensions(extensionArr)</span><br><span class="line">    include(<span class="string">'another.js'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>在我自己的分支中，include函数支持加载选项。默认加载选项是兼容方式加载（为满足支持OC，会通过正则表达式替换部分函数的调用方法），而第三方库是不需要被改变的。第二个参数是加载选项，默认是0或者不传入第二个参数，加载第三方库是1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    include(<span class="string">'thridparty.js'</span>, <span class="number">1</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="五、JSPatch中的实现技巧"><a name="jspatch-Tech">五、JSPatch中的实现技巧</a></h2><h3 id="GCD的实现">GCD的实现</h3><p>JSPatch采用的是预先在JSContext中封装了对GCD的调用，才能在JS中使用GCD，其代码如下。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">JSContext</span> *weakCtx = context;</span><br><span class="line">  context[<span class="string">@"dispatch_after"</span>] = ^(<span class="keyword">double</span> time, <span class="built_in">JSValue</span> *func) &#123;</span><br><span class="line">      <span class="built_in">JSValue</span> *currSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          <span class="built_in">JSValue</span> *prevSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = currSelf;</span><br><span class="line">          [func callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = prevSelf;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  context[<span class="string">@"dispatch_async_main"</span>] = ^(<span class="built_in">JSValue</span> *func) &#123;</span><br><span class="line">      <span class="built_in">JSValue</span> *currSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">      <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          <span class="built_in">JSValue</span> *prevSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = currSelf;</span><br><span class="line">          [func callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = prevSelf;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  context[<span class="string">@"dispatch_sync_main"</span>] = ^(<span class="built_in">JSValue</span> *func) &#123;</span><br><span class="line">      <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread]<span class="variable">.isMainThread</span>) &#123;</span><br><span class="line">          [func callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              [func callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  context[<span class="string">@"dispatch_async_global_queue"</span>] = ^(<span class="built_in">JSValue</span> *func) &#123;</span><br><span class="line">      <span class="built_in">JSValue</span> *currSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">      <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">          <span class="built_in">JSValue</span> *prevSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = currSelf;</span><br><span class="line">          [func callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = prevSelf;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中有三点需要注意：</p>
<ol>
<li><p>在block里是不能直接使用context的，因为会造成循环引用。所以在这里有两个处理方式，要么是使用__weak修饰符，要么就是使用JavascriptCore.framework提供的api<br><code>[JSContext currentContext]</code>。</p>
</li>
<li><p>在调用JSContext的<code>callWithArguments:</code>实例方法时，需要先保存JSContext中的实例对象<code>self</code>，调用完之后再重新赋值回去。否则在调用完JS方法后，<code>self</code>会变成nil</p>
</li>
<li><p>还有一点就是在<code>dispatch_sync_main</code>这个方法里，作者对代码所在的运行线程进行了一个判断，如果已经在主线程中就直接执行这个block，防止了死锁的发生。</p>
</li>
</ol>
<h3 id="处理JS脚本的异常">处理JS脚本的异常</h3><p>如果JS脚本出现了异常的话，在OC这边是不会知道的，需要使用JavaScriptCore.framwork中的exceptionHandler才能捕获这个异常，具体代码如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context<span class="variable">.exceptionHandler</span> = ^(<span class="built_in">JSContext</span> *con, <span class="built_in">JSValue</span> *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, exception);</span><br><span class="line">        <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"js exception: %@"</span>, exception);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h3 id="使用#pragma来抑制warning">使用#pragma来抑制warning</h3><p>作者使用#pargama宏来对一些warning进行了抑制，详细的介绍可以看参考<a href="http://nshipster.cn/clang-diagnostics/" target="_blank" rel="external">Matt Thomson写的一篇关于clang diagnostics的文章</a>，里面提供了一个<a href="http://fuckingclangwarnings.com/" target="_blank" rel="external">网站</a>详细地记录了抑制各种warning的写法。</p>
<h3 id="使用宏来预定义IMP函数">使用宏来预定义IMP函数</h3><p>由于要替换原有的函数实现，所以要预先定义好各种返回类型的IMP函数。如果全部写出来的话，将会耗费大量篇幅来写差不多的函数实现，这里作者使用了宏来进行替换，具体代码如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#define JPMETHOD_IMPLEMENTATION(_type, _typeString, _typeSelector) \</span></span><br><span class="line">    <span class="built_in">JPMETHOD_IMPLEMENTATION_RET</span>(_type, _typeString, <span class="keyword">return</span> [[ret toObject] _typeSelector]) \</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define JPMETHOD_IMPLEMENTATION_RET(_type, _typeString, _ret) \</span></span><br><span class="line"><span class="keyword">static</span> _type <span class="built_in">JPMETHOD_IMPLEMENTATION_NAME</span>(_typeString) (<span class="keyword">id</span> slf, <span class="built_in">SEL</span> selector) &#123;    \</span><br><span class="line">    <span class="built_in">JSValue</span> *fun = get<span class="built_in">JSFunctionInObjectHierachy</span>(slf, selector);    \</span><br><span class="line">    <span class="built_in">JSValue</span> *ret = [fun callWithArguments:_TMPInvocationArguments];  \</span><br><span class="line">    _ret;    \</span><br><span class="line">&#125;   \</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define JPMETHOD_IMPLEMENTATION_NAME(_typeString) JPMethodImplement_##_typeString</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic push</span></span><br><span class="line"><span class="preprocessor">#pragma clang diagnostic ignored <span class="title">"-Wunused-variable"</span></span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define JPMETHOD_RET_ID \</span></span><br><span class="line">    <span class="keyword">id</span> obj = format<span class="built_in">JSToOC</span>(ret); \</span><br><span class="line">    <span class="keyword">if</span> ([obj isKindOf<span class="built_in">Class</span>:[<span class="built_in">NSNull</span> class]]) <span class="keyword">return</span> <span class="literal">nil</span>;  \</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#define JPMETHOD_RET_STRUCT(_methodName)    \</span></span><br><span class="line">    <span class="keyword">id</span> dict = format<span class="built_in">JSToOC</span>(ret);   \</span><br><span class="line">    <span class="keyword">return</span> _methodName(dict);</span><br><span class="line"></span><br><span class="line"><span class="built_in">JPMETHOD_IMPLEMENTATION_RET</span>(<span class="keyword">void</span>, v, <span class="literal">nil</span>)</span><br><span class="line"><span class="built_in">JPMETHOD_IMPLEMENTATION_RET</span>(<span class="keyword">id</span>, <span class="keyword">id</span>, <span class="built_in">JPMETHOD_RET_ID</span>)</span><br><span class="line"><span class="built_in">JPMETHOD_IMPLEMENTATION_RET</span>(<span class="built_in">CGRect</span>, rect, <span class="built_in">JPMETHOD_RET_STRUCT</span>(dictToRect))</span><br><span class="line"><span class="built_in">JPMETHOD_IMPLEMENTATION_RET</span>(<span class="built_in">CGSize</span>, size, <span class="built_in">JPMETHOD_RET_STRUCT</span>(dictToSize))</span><br><span class="line"><span class="built_in">JPMETHOD_IMPLEMENTATION_RET</span>(<span class="built_in">CGPoint</span>, point, <span class="built_in">JPMETHOD_RET_STRUCT</span>(dictToPoint))</span><br><span class="line"><span class="built_in">JPMETHOD_IMPLEMENTATION_RET</span>(<span class="built_in">NSRange</span>, range, <span class="built_in">JPMETHOD_RET_STRUCT</span>(dictToRange))</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="六、遇到的问题与解决方法"><a name="jspatch-problem">六、遇到的问题与解决方法</a></h2><p>在与bang维护与开发JSPatch的过程中，也遇到过一些比较棘手的问题，这里总结一下。</p>
<h3 id="1-_在JSPatch中初始化UIWebView导致HTML无法渲染">1. 在JSPatch中初始化UIWebView导致HTML无法渲染</h3><p>这个问题最初是由一个JSPatch用户在<a href="https://github.com/bang590/JSPatch/issues/61" target="_blank" rel="external">issue</a>中提出。具体的表现是当在JSPatch中声明一个UIWebView，并对一个URL调用loadRequest方法后，无法渲染该HTML页面。<br><img src="https://cloud.githubusercontent.com/assets/7334742/8666691/731b0354-2a27-11e5-95cc-90df45fac11f.png" alt="图片"><br>后来经过查资料发现在JSContext中初始化UIWebView就会<a href="http://stackoverflow.com/questions/28638293/creating-a-uiwebview-from-a-jscontext-block-prevents-assets-from-loading-on-ios8" target="_blank" rel="external">出现这个问题</a>。</p>
<p>我猜测是<code>UIWebView</code>在初始化的过程中会初始化一个全局的<code>JSContext</code>对象，但是JSPatch也有用到<code>JSContext</code>，这其中造成了某种冲突。导致在<code>UIWebView</code>初始化JSContext失败。</p>
<p><strong>解决方法:</strong></p>
<p>1、在JSPatch之外启动调用一次<code>UIWebView</code>的<code>init</code>方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    <span class="built_in">UIWebView</span> *view = [[<span class="built_in">UIWebView</span> alloc]init];   <span class="comment">//Useless. Just to load the UIWebview framework.</span></span><br><span class="line">    view<span class="variable">.frame</span> = <span class="built_in">CGRectZero</span>;</span><br><span class="line"></span><br><span class="line">    [<span class="built_in">JPEngine</span> startEngine];</span><br><span class="line">   <span class="comment">//.......</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2、在JSPatch中显式地创建UIWebView的JSContext</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defineClass('UIWebView',&#123;</span><br><span class="line">	 loadRequest :function(request)&#123;</span><br><span class="line">	 	self.valueForKeyPath("documentView.webView.mainFrame.javaScriptContext")  		</span><br><span class="line">	 	self.ORIGloadRequest(request)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="2-_无法调用参数为id_*类型的方法">2. 无法调用参数为id *类型的方法</h3><p>在上面的章节中我介绍了我是如何在JS中调用一个参数是指针的方法:</p>
<ol>
<li>通过<code>JPMemoery</code>Extension中的<code>malloc</code>声明一个指针或者调用<code>getpointer</code>去获得一个对象的地址。</li>
<li>调用方法后使用<code>pval</code>方法来获得指针所指的对象。</li>
</ol>
<p>这种方法调用像NSInvocation中的<code>- (void)getReturnValue:(void *)retLoc</code>、<code>- (void)setArgument:(void *)argumentLocation atIndex:(NSInteger)idx;</code>以及一些C API没有任何问题。</p>
<p>但是如果调用NSString中的<code>- (BOOL)writeToFile:(NSString *)path atomically:(BOOL)useAuxiliaryFile encoding:(NSStringEncoding)enc error:(NSError **)error</code>则会发现传进去的指针参数所指向的NSError对象在回到JS环境的时候已经被释放了。</p>
<p>实际上NSError <em>*参数在编译器中会被解释成NSError \</em>__autoreleasing*类型，该对象生成后将会被加入到autoreleasing pool中，开发者无法控制他的释放时机。随后，我对各个关键点进行打断点对这个自动释放对象进行跟中，发现这个对象一回到JSContext的执行环境就会被释放。</p>
<p><strong>解决方法：</strong></p>
<p>解决这个问题的思路是在调用完参数为id *类型的方法后(<code>callSelector</code>中调用完<code>[invocation inoke]</code>后)，对该自动释放对象进行强引用，使得这个对象在回到JS环境的时候依然存在。这里我使用了一个NSDictonry作为临时自动释放对象的内存池，当生成一个自动释放对象后，将其添加到内存池中(key为其内存地址)，使得这个自动释放对象被内存池强引用。保证了在JS环境中可以访问到该对象，不需要该对象时再手动释放该对象(remove掉内存池的对象)。具体逻辑如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">'^'</span>: &#123;</span><br><span class="line">                <span class="keyword">if</span> ([valObj isKindOf<span class="built_in">Class</span>:[<span class="built_in">JPBoxing</span> class]]) &#123;</span><br><span class="line">                    <span class="keyword">void</span> *value = [((<span class="built_in">JPBoxing</span> *)valObj) unboxPointer];</span><br><span class="line">                    <span class="keyword">if</span> (argumentType[<span class="number">1</span>] == <span class="string">'@'</span>) &#123;</span><br><span class="line">                        memset(value, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>));</span><br><span class="line">                        [_markArray addObject:valObj];</span><br><span class="line">                    &#125;</span><br><span class="line">                    [invocation setArgument:&amp;value atIndex:i];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
<p>当参数类型是指针的时候进行一个判断，如果指针所指的是id类型。则将JPBoxing加入到一个_markArray中。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//...</span></span><br><span class="line">[invocation invoke];</span><br><span class="line">    <span class="keyword">if</span> ([_markArray count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">JPBoxing</span> *box <span class="keyword">in</span> _markArray) &#123;</span><br><span class="line">            <span class="keyword">void</span> *pointer = [box unboxPointer];</span><br><span class="line">            <span class="keyword">id</span> obj = *((__unsafe_unretained <span class="keyword">id</span> *)pointer);</span><br><span class="line">            <span class="keyword">if</span> (obj) &#123;</span><br><span class="line">                <span class="keyword">@synchronized</span>(_TMPMemoryPool) &#123;</span><br><span class="line">                    [_TMPMemoryPool setObject:obj forKey:[<span class="built_in">NSNumber</span> numberWithInteger:[obj hash]]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果_markArray大小不为零，则将数组中的JPBoxing中指针所指对象加入到内存池中（key为对象的hashCode），使得自动释放对象被强引用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">context[<span class="string">@"releaseTmpObj"</span>] = ^<span class="keyword">void</span>(<span class="built_in">JSValue</span> *jsVal) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[jsVal toObject] isKindOf<span class="built_in">Class</span>:[<span class="built_in">NSDictionary</span> class]]) &#123;</span><br><span class="line">            <span class="keyword">void</span> *pointer =  [(<span class="built_in">JPBoxing</span> *)([jsVal toObject][<span class="string">@"__obj"</span>]) unboxPointer];</span><br><span class="line">            <span class="keyword">id</span> obj = *((__unsafe_unretained <span class="keyword">id</span> *)pointer);</span><br><span class="line">            <span class="keyword">@synchronized</span>(_TMPMemoryPool) &#123;</span><br><span class="line">                [_TMPMemoryPool removeObjectForKey:[<span class="built_in">NSNumber</span> numberWithInteger:[obj hash]]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>JSPatch脚本中调用<code>releaseTmpObj</code>方法手动释放该临时对象。</p>
<h2 id="七、工作总结和未来计划"><a name="conclusion">七、工作总结和未来计划</a></h2><p>自进入基础优化组以来已经过了一个半月，期间我对在iOS平台下使用脚本语言进行热更新进行了比较细致的研究，并且亲身参与到开发和维护JSPatch这个项目之中。</p>
<p>JSPatch中我参与的部分以及总结如下：</p>
<h4 id="功能开发:"><strong>功能开发:</strong></h4><p>1、 为JSPatch添加了C API的扩展。我首先需要知道微信项目中的C API调用情况，通过otool工具将微信项目中的二进制文件反编译成汇编，会得到以下的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000000010004</span>b888	callq	__ZL11CGPointMakedd     <span class="preprocessor">## CGPointMake(double, double)</span></span><br><span class="line"><span class="number">000000010004</span>b88d	movsd	%xmm0, -<span class="number">0x80</span>(%rbp)</span><br><span class="line"><span class="number">000000010004</span>b892	movsd	%xmm1, -<span class="number">0x78</span>(%rbp)</span><br><span class="line"><span class="number">000000010004</span>b897	callq	<span class="number">0x10012bd22</span>             <span class="preprocessor">## symbol stub for: _UIGraphicsGetCurrentContext</span></span><br><span class="line"><span class="number">000000010004</span>b89c	movq	%rax, -<span class="number">0x88</span>(%rbp)</span><br><span class="line"><span class="number">000000010004</span>b8a3	movl	$<span class="number">0x1</span>, %edx</span><br><span class="line"><span class="number">000000010004</span>b8a8	movq	%rax, %rdi</span><br><span class="line"><span class="number">000000010004</span>b8ab	movl	%edx, %esi</span><br><span class="line"><span class="number">000000010004</span>b8ad	movl	%edx, -<span class="number">0x104</span>(%rbp)</span><br><span class="line"><span class="number">000000010004</span>b8b3	callq	<span class="number">0x10012bc3e</span>             <span class="preprocessor">## symbol stub for: _CGContextSetShouldAntialias</span></span><br><span class="line"><span class="number">000000010004</span>b8b8	movq	-<span class="number">0x88</span>(%rbp), %rdi</span><br><span class="line"><span class="number">000000010004</span>b8bf	movl	-<span class="number">0x104</span>(%rbp), %esi</span><br><span class="line"><span class="number">000000010004</span>b8c5	callq	<span class="number">0x10012bc02</span>             <span class="preprocessor">## symbol stub for: _CGContextSetAllowsAntialiasing</span></span><br><span class="line"><span class="number">000000010004</span>b8ca	movq	-<span class="number">0x88</span>(%rbp), %rdi</span><br><span class="line"><span class="number">000000010004</span>b8d1	movl	$<span class="number">0x11</span>, %esi</span><br><span class="line"><span class="number">000000010004</span>b8d6	callq	<span class="number">0x10012bc08</span>             <span class="preprocessor">## symbol stub for: _CGContextSetBlendMode</span></span><br></pre></td></tr></table></figure>
<p>在汇编代码中可看出，<code>## symbol stub for:</code>后的是 C API的调用，而<code>##</code>后面的是内联函数的调用。我将这些API的名字扫描出来并进行分类后，得到了一些常用的C API并添加到Extensions中。现已包括Foundation、CoreFoundation、CoreGraphics、UIKit，JPMemory这些常用的框架中的C API。并可以通过扩展框架头文件引入整个框架，而不需要一个一个导入。</p>
<p>2、 为支持C API的扩展，增加了对指针和Class变量的封装以及拆解。因为JS中并不能使用以及声明一个指针，而在C API中，指针作为参数是非常常见的，所以需要将指针封装在一个JPBoxing中，并以{“__className”:”JPBoxing”，”__obj”:[JPBoxing boxPointer:pointer]}的形式回传回JS。下次调用的时候再将__obj中的指针拆解出来。</p>
<p>3、 支持对第三方库的调用。在include方法中增加了对第三方js库调用的支持。</p>
<p>4、 添加了sizeof方法。通过遍历加载到JS中的Extension中实现JPExtension协议的<code>- (size_t)sizeOfStructWithTypeName:(NSString *)typeName</code>方法，使得在JS端可以通过传入一个字符串的形式:<code>sizeof(&#39;CGRect&#39;)</code>来获取不同strut类型变量的大小，配合JPMemory扩展中的方法可以malloc出一块指定大小的内存，传入到某些C API中。</p>
<p>5、 添加JPMemory扩展，Javascript中是无法操作具体的内存也没有指针的概念，但是通过JPMemory扩展，可以让JSPatch拥有操作与访问内存的功能，以及获取对象的指针、指针的指针的功能。</p>
<p>6、 添加了保存的__autoreleasing对象机制，使自动释放对象在返回到JS运行环境的时候不会被自动释放，在JS脚本可以继续访问。使用一个NSDictonry作为临时自动释放对象的内存池，当生成一个自动释放对象后，将其添加到内存池中(key为其内存地址)，使得这个自动释放对象被内存池强引用。保证了在JS环境中可以访问到该对象，不需要的时候再手动释放该对象(remove掉内存池的对象)。</p>
<h4 id="维护："><strong>维护：</strong></h4><p>1、 修复了在JS中<a href="https://github.com/bang590/JSPatch/commit/3c9a10cd86fc13f7e0909bb3a2a93bba286aa1c9" target="_blank" rel="external">传递nil参数时造成的崩溃</a>。JavaScript中并没有nil这个类型的参数，只有undefined以及null类型。桥接的时候JavascriptCore.framework会将js中的null类型转换为OC中的[NSNull null]类型，所以在调用方法时必须加以判断，将[NSNull null]转换为nil。为了防止真需要传递[NSNull null]参数，在JS中设置了一个名为nsnull的全局变量，开发者如要传递[NSNull null]则可以使用nsnull。</p>
<p>2、 修复了使用JSPatch判断struct时造成的<a href="https://github.com/bang590/JSPatch/commit/6df89bec6c8f4217500be316832fecbd898d1b46" target="_blank" rel="external">误判</a>。原作者bang原本使用的@encode()方法产生的C字符串来遍历加载到JS中的所有extension的<code>- (size_t)sizeOfStructWithTypeEncode:(NSString *)typeName</code>方法，@encode产生结果是这样的形式:<code>{CGPoint=dd}</code>，并使用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[typeEncode rangeOfString:<span class="string">@"CGPoint"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>;</span><br></pre></td></tr></table></figure>
<p>进行匹配。但事实上这样的方法是会导致CGPoint被误判为CGRect，因为CGRect进行@encode的结果为<code>{CGRect={CGPoint=dd}{CGSize=dd}}</code>。而后bang提议改为</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[typeEncode rangeOfString:<span class="string">@"CGPoint"</span>]<span class="variable">.location</span> == <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>但是这样会与sizeof功能有所冲突，而且在随后的测试中我发现@encode(NSRange)的结果为<code>{_NSRange=QQ}</code>，所以检测location==1也是不可以行的。最后我通过<a href="https://github.com/bang590/JSPatch/blob/6df89bec6c8f4217500be316832fecbd898d1b46/JSPatch/JPEngine.m#L1003" target="_blank" rel="external">提取出typeEncode中第一个Struct的名字</a>解决了这一问题</p>
<p>3、 修复了JSPatch添加Extension时造成<a href="https://github.com/bang590/JSPatch/commit/c20e2910ee8e73e3ae22db071a43072c9e6ca149" target="_blank" rel="external">无限循环加载</a>的问题。</p>
<p>代码提交情况: <a href="https://github.com/bang590/JSPatch/graphs/contributors" target="_blank" rel="external">1916++ / 348—</a> 及 <a href="https://github.com/bang590/JSPatch/commits/master" target="_blank" rel="external">commit log</a></p>
<h4 id="未来计划">未来计划</h4><p>JSPatch功能上已能满足hot fix动态修复的基本需求。接下来的工作重点主要添加脚本的传输和脚本加密的机制，防止未授权的第三方对脚本进行串改；集成进项目中测试实际性能和内存占用情况，改善性能；根据业务需求继续添加常用扩展API。</p>
<p>在JSPatch的讨论群中以及与原作者bang的讨论中，我学习到了不少以前没接触过的知识与技术，让我获益匪浅，也让我感觉到了与真正的高手之间的差距。实习的这一个月里，除了工作任务之外我还收获学习到其他的东西，比如说通过在github上贡献代码使得我对git的使用更加熟练，还学会了使用githubpages搭建自己的<a href="http://albert43.net" target="_blank" rel="external">技术博客</a>，非常充实。在接下来的实习工作中我会继续保持干劲，努力提高自己。</p>
<p>（持续更新中…）</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSPatch/">JSPatch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-iOS开发-NSInvocation另外一种获取returnValue的形式" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/10/iOS开发-NSInvocation另外一种获取returnValue的形式/" class="article-date">
  	<time datetime="2015-07-10T03:34:05.000Z" itemprop="datePublished">2015-07-10</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/10/iOS开发-NSInvocation另外一种获取returnValue的形式/">iOS开发:NSInvocation另外一种获取returnValue的形式</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="NSInvocation简介">NSInvocation简介</h1><p>iOS开发中，有时候我们会使用<code>performSelector:withObject</code>或<code>performSelector:withObject:withObject</code>来对Selector进行调用, 但是这个方法有个缺点就是只能调用包涵两个或以下的参数的方法。</p>
<p>这时候我们就可以NSInvocation来对方法进行调用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">SEL</span> selector = <span class="keyword">@selector</span>(stringCatWtihStr1:str2:);</span><br><span class="line"><span class="built_in">NSMethodSignature</span> *signature = [[MyObject class] 	instanceMethodSignatureForSelector:selector];</span><br><span class="line"><span class="built_in">NSString</span> *str1 = <span class="string">@"Hello"</span>;</span><br><span class="line"><span class="built_in">NSString</span> *str2 = <span class="string">@"World"</span>;</span><br><span class="line"><span class="built_in">NSInvocation</span> *invocation = [<span class="built_in">NSInvocation</span> invocationWithMethodSignature:signature];</span><br><span class="line">MyObject *object = [[MyObject alloc]init];</span><br><span class="line">[invocation setTarget:object];</span><br><span class="line">[invocation setSelector:selector];</span><br><span class="line">[invocation setArgument:&amp;str1 atIndex:<span class="number">2</span>];</span><br><span class="line">[invocation setArgument:&amp;str2 atIndex:<span class="number">3</span>];</span><br><span class="line"><span class="built_in">NSString</span> *result = <span class="literal">nil</span>;</span><br><span class="line">[invocation retainArguments];</span><br><span class="line">[invocation invoke];</span><br><span class="line">[invocation getReturnValue:&amp;result];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"%@"</span>,result);</span><br></pre></td></tr></table></figure>
<p>首先需要获得这个方法的签名，确定一个方法需要selector以及这个selector所属的类。<br>通过这个方法签名便可以构造一个NSInvocation实例，通过设置Target，selector，arguments便可以通过<code>invoke</code>方法进行调用，最后通过<code>getReturnValue</code>来获取result。</p>
<p>通常我们都会使用以下方式去获取返回值。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *result = <span class="literal">nil</span>;</span><br><span class="line">[invocation getReturnValue:&amp;result];</span><br></pre></td></tr></table></figure>
<p>我们可以看一下<code>getReturnValue</code>方法的原型。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)getReturnValue:(<span class="keyword">void</span> *)retLoc;</span><br></pre></td></tr></table></figure>
<p>可以看出retLoc是一个地址指针。那我们就以另外一种方式去获取getReturnValue。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = malloc(<span class="keyword">sizeof</span>(<span class="keyword">id</span>));  <span class="comment">//malloc一个地址指针</span></span><br><span class="line">[invocation getReturnValue:p]; <span class="comment">//传入这个地址指针</span></span><br><span class="line"><span class="keyword">id</span> ret = (__bridge <span class="keyword">id</span>)(*(<span class="keyword">void</span> **)p) <span class="comment">//取这块地址内存中内容</span></span><br></pre></td></tr></table></figure>
<p>解释一些这个指针操作，因为id类型实质上是一个指针，所以id类型的指针是(void **)，所以需要先将p地址转换为一个id类型的地址，再进行dereference操作。最后bridge为一个id类型。</p>
<p>这种方法不同于常规，先声明一个变量，再传入这个变量的内存地址。而是先构造一个指向一个地址，随后传入这个地址，最后获取这个地址的内存中的内容。</p>
<p>在JS中是没有取地址这个操作，所以我们没有办法使用[invocation getReturnValue:&amp;ret]的这种形式。但是我们可以malloc一个内存地址（通过JSBinding和封装指针到一个对象的方式，详见JSPatch的实现)，按照上述的方式去获得returnValue。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-JSPatch开发-Extension" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/07/07/JSPatch开发-Extension/" class="article-date">
  	<time datetime="2015-07-07T04:13:29.000Z" itemprop="datePublished">2015-07-07</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/07/07/JSPatch开发-Extension/">JSPatch开发: Extension机制</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="JPExtesnion对C_API和Struct进行扩展">JPExtesnion对C API和Struct进行扩展</h2><p>在上一篇的文章中，我对如何在JSPatch中调用C API进行了介绍。 但是面对大量的C API， 需要一个满足以下需求的扩展机制</p>
<ol>
<li>可模块化加载</li>
<li>js脚本可动态加载。</li>
<li>可以在extension添加struct</li>
</ol>
<p>以下是JPExtension协议的定义，所有的extension都需要继承JPExtension协议</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">JPExtensionProtocol</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)main:(<span class="built_in">JSContext</span> *)context;</span><br><span class="line"></span><br><span class="line">- (size_t)sizeOfStructWithTypeName:(<span class="built_in">NSString</span> *)typeName;</span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)dictOfStruct:(<span class="keyword">void</span> *)structData typeName:(<span class="built_in">NSString</span> *)typeName;</span><br><span class="line">- (<span class="keyword">void</span>)structData:(<span class="keyword">void</span> *)structData ofDict:(<span class="built_in">NSDictionary</span> *)dict typeName:(<span class="built_in">NSString</span> *)typeName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>
<p>开发者可在<code>- (void)main:(JSContext *)context</code>中添加C API， C API会被添加到JS所在的执行上下文即context，定义C API和注意的地方等会再详述。而后面的三个方法从方法名可以知道，extension中如果要定义struct的话则需要实现这三个方法。因为JS中是无法定义和使用c struct的，所以需要提供相应的互相转换方法，具体实现以<code>CGAffineTransform</code>为例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (size_t)sizeOfStructWithTypeName:(<span class="built_in">NSString</span> *)typeName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([typeName rangeOfString:<span class="string">@"CGAffineTransform"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">sizeof</span>(<span class="built_in">CGAffineTransform</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSDictionary</span> *)dictOfStruct:(<span class="keyword">void</span> *)structData typeName:(<span class="built_in">NSString</span> *)typeName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([typeName rangeOfString:<span class="string">@"CGAffineTransform"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        <span class="built_in">CGAffineTransform</span> *trans = (<span class="built_in">CGAffineTransform</span> *)structData;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">JPCGTransform</span> transDictOfStruct:trans];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)structData:(<span class="keyword">void</span> *)structData ofDict:(<span class="built_in">NSDictionary</span> *)dict typeName:(<span class="built_in">NSString</span> *)typeName</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> ([typeName rangeOfString:<span class="string">@"CGAffineTransform"</span>]<span class="variable">.location</span> != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">        [<span class="built_in">JPCGTransform</span> transStruct:structData ofDict:dict];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现了这三个方法后，JPEngine会将实现了这三个方法extesnion放入_structExtension内。当在JS中调用含有相关struct的方法时，JSEngine会遍历整个_structExtension，找到相应的转换方法。</p>
<p>根据JPExtension协议，模块化加载就变得非常简单：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)main:(<span class="built_in">JSContext</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSArray</span> *extensionArray = @[[<span class="built_in">JPCGTransform</span> instance],[<span class="built_in">JPCGContext</span> instance],</span><br><span class="line">                                            [<span class="built_in">JPCGGeometry</span> instance],[<span class="built_in">JPCGBitmapContext</span> instance],</span><br><span class="line">                                            [<span class="built_in">JPCGColor</span> instance],[<span class="built_in">JPCGImage</span> instance],[<span class="built_in">JPCGPath</span> instance]];</span><br><span class="line">    [<span class="built_in">JPEngine</span> addExtensions:extensionArray];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JS脚本则可以这样调用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> extensionArr = [<span class="built_in">require</span>(<span class="string">'JPCoreGraphics'</span>).instance(),<span class="built_in">require</span>(<span class="string">'JPUIKit'</span>).instance()]</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'JPEngine'</span>).addExtensions(extensionArr)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>当然，你也只调用你需要的模块。</p>
<h2 id="C_API定义时需要注意的问题">C API定义时需要注意的问题</h2><p>C API中，有大量的参数或者是返回类型都是指针，包括像CGContextRef这种也是指针。我们知道JS中是没有指针这一说的，JS中也无法使用OC中的对象，JS中能使用的对象在OC中实际上NSDictionary *类型，所以从OC端返回给JS端时必须用一个封装对象(JPBoxing)来将指针和对象封装起来。JPExtension提供了以下API来封装OC中的对象和指针成JPBoxing和将JPBoxing对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span> *)formatPointer<span class="built_in">JSToOC</span>:(<span class="built_in">JSValue</span> *)val;</span><br><span class="line">- (<span class="keyword">id</span>)formatPointerOCTo<span class="built_in">JS</span>:(<span class="keyword">void</span> *)pointer;</span><br><span class="line">- (<span class="keyword">id</span>)format<span class="built_in">JSToOC</span>:(<span class="built_in">JSValue</span> *)val;</span><br><span class="line">- (<span class="keyword">id</span>)formatOCTo<span class="built_in">JS</span>:(<span class="keyword">id</span>)obj;</span><br></pre></td></tr></table></figure>
<p>C API封装实例:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">context[<span class="string">@"UIGraphicsGetCurrentContext"</span>] = ^<span class="keyword">id</span>() &#123;</span><br><span class="line">        <span class="built_in">CGContextRef</span> c = <span class="built_in">UIGraphicsGetCurrentContext</span>();</span><br><span class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> formatPointerOCTo<span class="built_in">JS</span>:c];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">context[<span class="string">@"UIGraphicsBeginImageContext"</span>] = ^<span class="keyword">void</span>(<span class="built_in">NSDictionary</span> *sizeDict) &#123;</span><br><span class="line">        <span class="built_in">CGSize</span> size;</span><br><span class="line">        [<span class="built_in">JPCGGeometry</span> sizeStruct:&amp;size ofDict:sizeDict];</span><br><span class="line">        <span class="built_in">UIGraphicsBeginImageContext</span>(size);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>注意到<code>UIGraphicsGetCurrentContext()</code>中返回的是一个CGContextRef类型，所以添加这个扩展API的时候需要将返回类型改为id类型，并将CGContextRef指针封装在JPBoxing中。而<code>UIGraphicsBeginImageContext()</code>需要的是一个CGSize参数，这时候需要在JS端传入一个<code>{x:100,y:100}</code>的Javascript object，这个object会在OC中被转换为NSDictionary.</p>
<p>C API的返回值的返回类型也是一个需要根据情况去判断，当返回的结果是JavascriptCore.Framework所不支持转换的类型(NSArray, NSDictionary, NSString, NSNumber, NSBlock)，则需要通过<code>formatOCToJS:</code>方法来封装返回。而且返回类型是NSArray, NSDictionary, NSString时，如果你直接返回，JavascriptCore会将返回值转换为JS中的Array, Object, String，你就无法再使用OC的方法。如果你想在JS中使用这三种类型的方法，也需要用<code>formatOCToJS:</code>方法进行封装。</p>
<h2 id="include函数">include函数</h2><p>在JSPatch最新的更新中，支持了在JS中调用include方法。可以在一个JS文件中加载其他JS文件，包括补丁脚本、第三方脚本。</p>
<p>使用方法如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> extensionArr = [<span class="built_in">require</span>(<span class="string">'JPInclude'</span>).instance()]</span><br><span class="line">    <span class="built_in">require</span>(<span class="string">'JPEngine'</span>).addExtensions(extensionArr)</span><br><span class="line">    include(<span class="string">'another.js'</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p>在我自己的分支中，include函数支持加载选项。默认加载选项是兼容方式加载（为满足支持OC，会通过正则表达式替换部分函数的调用方法），而第三方库是不需要被改变的。第二个参数是加载选项，默认是0或者不传入第二个参数，加载第三方库是1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    include(<span class="string">'thridparty.js'</span>,<span class="number">1</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSPatch/">JSPatch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-JSPatch开发-如何在JS中调用C函数" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/30/JSPatch开发-如何在JS中调用C函数/" class="article-date">
  	<time datetime="2015-06-30T10:08:27.000Z" itemprop="datePublished">2015-06-30</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/30/JSPatch开发-如何在JS中调用C函数/">JSPatch开发:如何在JS中调用C函数</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>我们知道JSPatch是运用Objective-C runtime和JSBinding技术来在JS中调用Objective-C的方法，但是打补丁的时候难免会要调用到C函数。但是C函数是无法通过runtime来调用的。那怎么办呢？</p>
<p>这里以CGRectMake()来作为例子，如果想在JS中使用CGRectMake()函数，则需要首先起动JPEngine的时候，将CGRectMake预定义在JSContext之中。</p>
<p>而且有一点要注意的，CGRectMake返回的并不是一个对象，而是一个struct类型的变量。struct类型是无法返回到JS环境的，所以要封装成NSDictionary的形式。</p>
<p>所以首先要定义一个方法来将struct转换成NSDictionary</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="built_in">NSDictionary</span> *)dictOfStruct:(<span class="keyword">void</span> *)structData typeString:(<span class="keyword">const</span> <span class="keyword">char</span>*)type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (strcmp(type, @encode(<span class="built_in">CGRect</span>)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">CGRect</span> *rect = structData;</span><br><span class="line">        <span class="keyword">return</span> @&#123;<span class="string">@"x"</span>: @(rect-&gt;origin<span class="variable">.x</span>), <span class="string">@"y"</span>: @(rect-&gt;origin<span class="variable">.y</span>), <span class="string">@"width"</span>: @(rect-&gt;size<span class="variable">.width</span>), <span class="string">@"height"</span>: @(rect-&gt;size<span class="variable">.height</span>)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//下面接着定义其他类型的Struct</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样就可以在startEngine中定义CGRectMake方法了，具体如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context[<span class="string">@"_OC_CGRectMake"</span>] = ^<span class="keyword">id</span>(<span class="built_in">JSValue</span> *x, <span class="built_in">JSValue</span> *y, <span class="built_in">JSValue</span> *width, <span class="built_in">JSValue</span> *height)&#123;</span><br><span class="line">        <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>([x toDouble], [y toDouble], [width toDouble], [height toDouble]);</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">JPEngine</span> dictOfStruct:&amp;rect typeString:@encode(<span class="built_in">CGRect</span>)];</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在JSPatch.js中添加全局变量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">global.CGRectMake = _OC_CGRectMake;</span><br></pre></td></tr></table></figure>
<p>在JS中就可以如此调用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">defineClass(<span class="string">'JPViewController'</span>, &#123;</span><br><span class="line">  handleBtn: <span class="function"><span class="keyword">function</span>(<span class="params">sender</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> frame = CGRectMake(<span class="number">0</span>,<span class="number">0</span>,<span class="number">200</span>,<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">var</span> subView  = <span class="built_in">require</span>(<span class="string">'UIView'</span>).alloc().initWithFrame(frame)</span><br><span class="line"></span><br><span class="line">      subView.setBackgroundColor(<span class="built_in">require</span>(<span class="string">'UIColor'</span>).blueColor())</span><br><span class="line"></span><br><span class="line">      self.view().addSubview(subView)</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSPatch/">JSPatch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-JSPatch学习-核心和实现原理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/19/JSPatch学习-核心和实现原理/" class="article-date">
  	<time datetime="2015-06-19T09:17:45.000Z" itemprop="datePublished">2015-06-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/19/JSPatch学习-核心和实现原理/">JSPatch学习:JSPatch核心和实现原理分析</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近由于工作的原因开始学习JSPatch的源码，顺便测试JSPatch和帮忙提交bug fix。JSPatch现在还处于在开发阶段，<a href="https://github.com/bang590/JSPatch/commit/69450d535a26e3862d43fffdfc03a36f02a24896" target="_blank" rel="external">69450d5</a>版本出来后，JSPatch基本功能已经完成，后面要继续深入的话就是加入C API的扩展机制、埋入些经常使用C API，以及考虑传输和加密的机制。</p>
<h2 id="一、JSPatch核心">一、JSPatch核心</h2><h1 id="startEngine">startEngine</h1><p>首先我们来看看JSPatch是怎么使用的</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="built_in">JPEngine</span> startEngine];</span><br><span class="line">    <span class="built_in">NSString</span> *sourcePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@"demo"</span> ofType:<span class="string">@"js"</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *script = [<span class="built_in">NSString</span> stringWithContentsOfFile:sourcePath encoding:<span class="built_in">NSUTF8StringEncoding</span> error:<span class="literal">nil</span>];</span><br><span class="line">    [<span class="built_in">JPEngine</span> evaluateScript:script];</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先要调用<code>JPEngine</code>中的类方法<code>startEngine</code>， 调用这个方法的主要目的是先初始化JSContext， JSContext可以说是等会我们用到JS脚本的运行环境，在这里预定义的变量和方法都可以在JS脚本中被调用。作者在这里定义了除了刚刚提到的GCD类外，还定义几个关键的函数:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">context[<span class="string">@"_OC_defineClass"</span>] = ^(<span class="built_in">NSString</span> *classDeclaration, <span class="built_in">JSValue</span> *instanceMethods, <span class="built_in">JSValue</span> *classMethods) &#123;</span><br><span class="line">        <span class="keyword">return</span> define<span class="built_in">Class</span>(classDeclaration, instanceMethods, classMethods);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">context[<span class="string">@"_OC_callI"</span>] = ^<span class="keyword">id</span>(<span class="built_in">JSValue</span> *obj, <span class="built_in">NSString</span> *selectorName, <span class="built_in">JSValue</span> *arguments, <span class="built_in">BOOL</span> isSuper) &#123;</span><br><span class="line">        <span class="keyword">return</span> callSelector(<span class="literal">nil</span>, selectorName, arguments, obj, isSuper);</span><br><span class="line">    &#125;;</span><br><span class="line">context[<span class="string">@"_OC_callC"</span>] = ^<span class="keyword">id</span>(<span class="built_in">NSString</span> *className, <span class="built_in">NSString</span> *selectorName, <span class="built_in">JSValue</span> *arguments) &#123;</span><br><span class="line">        <span class="keyword">return</span> callSelector(className, selectorName, arguments, <span class="literal">nil</span>, <span class="literal">NO</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">context[<span class="string">@"_OC_formatJSToOC"</span>] = ^<span class="keyword">id</span>(<span class="built_in">JSValue</span> *obj) &#123;</span><br><span class="line">        <span class="keyword">return</span> format<span class="built_in">JSToOC</span>(obj);</span><br><span class="line">    &#125;;</span><br><span class="line">context[<span class="string">@"_OC_log"</span>] = ^() &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *args = [<span class="built_in">JSContext</span> currentArguments];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">JSValue</span> *jsVal <span class="keyword">in</span> args) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@"JSPatch.log: %@"</span>, jsVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="defineClass">defineClass</h1><p>接下来讲解JSPatch中如何定义一个类以及怎么覆盖原方法或新增一个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">defineClass(<span class="string">'JPViewController'</span>, &#123;</span><br><span class="line">  handleBtn: <span class="function"><span class="keyword">function</span>(<span class="params">sender</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> tableViewCtrl = JPTableViewController.alloc().init()</span><br><span class="line">    self.navigationController().pushViewController_animated(tableViewCtrl, YES)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>defineClass</code>函数可接受三个参数：</p>
<ol>
<li>字符串:”需要替换或者新增的类名:继承的父类名 &lt;实现的协议1, 实现的协议2&gt;”</li>
<li>{实例方法}</li>
<li>{类方法}</li>
</ol>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSPatch/">JSPatch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-JSPatch学习-实现技巧" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/18/JSPatch学习-实现技巧/" class="article-date">
  	<time datetime="2015-06-18T11:50:51.000Z" itemprop="datePublished">2015-06-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/18/JSPatch学习-实现技巧/">JSPatch学习:实现技巧</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="GCD的实现">GCD的实现</h1><p>我们知道JSPatch和Wax的核心技术都是在通过runtime技术来动态替换给类添加方法，但是GCD这种C API是没法通过runtime技术来获取的。这里我也花了时间研究，一开始想通过<a href="http://baike.baidu.com/link?url=tQcimwhSphQpM9I2nSCHWiYHfg7wjtddAsnqjTUvZjM0dGCv0e6PlCy84Ub7iCkEOClHdO-BVZCWyKYQxgFU8K" target="_blank" rel="external">dlsym函数</a>通过函数名来获取对应的函数地址，通过JS脚本传入C函数名称。但实际上还需要预先定义一个相同类型的函数指针才能调用，做不到完全的动态调用。而且还有一个问题就是像CGRectMake这种，实质上是内联函数，并没有对应的函数地址。</p>
<p>现在JSPatch采用的是预先在JSContext中封装了对GCD的调用，所以才能在JS中使用GCD，其代码如下。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">__<span class="keyword">weak</span> <span class="built_in">JSContext</span> *weakCtx = context;</span><br><span class="line">  context[<span class="string">@"dispatch_after"</span>] = ^(<span class="keyword">double</span> time, <span class="built_in">JSValue</span> *func) &#123;</span><br><span class="line">      <span class="built_in">JSValue</span> *currSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">      dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(time * <span class="built_in">NSEC_PER_SEC</span>)), dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          <span class="built_in">JSValue</span> *prevSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = currSelf;</span><br><span class="line">          [func callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = prevSelf;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  context[<span class="string">@"dispatch_async_main"</span>] = ^(<span class="built_in">JSValue</span> *func) &#123;</span><br><span class="line">      <span class="built_in">JSValue</span> *currSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">      <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          <span class="built_in">JSValue</span> *prevSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = currSelf;</span><br><span class="line">          [func callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = prevSelf;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  context[<span class="string">@"dispatch_sync_main"</span>] = ^(<span class="built_in">JSValue</span> *func) &#123;</span><br><span class="line">      <span class="keyword">if</span> ([<span class="built_in">NSThread</span> currentThread]<span class="variable">.isMainThread</span>) &#123;</span><br><span class="line">          [func callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">dispatch_sync</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              [func callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  context[<span class="string">@"dispatch_async_global_queue"</span>] = ^(<span class="built_in">JSValue</span> *func) &#123;</span><br><span class="line">      <span class="built_in">JSValue</span> *currSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">      <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(<span class="number">0</span>, <span class="number">0</span>), ^&#123;</span><br><span class="line">          <span class="built_in">JSValue</span> *prevSelf = weakCtx[<span class="string">@"self"</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = currSelf;</span><br><span class="line">          [func callWithArguments:<span class="literal">nil</span>];</span><br><span class="line">          weakCtx[<span class="string">@"self"</span>] = prevSelf;</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<p>其中要注意的地方一个是，在block里是不能直接使用context的，因为会造成循环引用。所以在这里有两个处理方式，要么是使用__weak修饰符，要么就是使用JavascriptCore.framework提供的api</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSContext</span> *currContext = [<span class="built_in">JSContext</span> currentContext];</span><br></pre></td></tr></table></figure>
<p>还有一点就是在<code>dispatch_sync_main</code>这个方法里，作者对代码所在的运行现成进行了一个判断，防止了死锁。具体的原理可以看《Objective-C 高级编程》一书中关于GCD的章节。</p>
<h1 id="JS脚本的异常处理">JS脚本的异常处理</h1><p>如果JS脚本出现了异常的话，在OC这边是不会知道的，使用JavaScriptCore.framwork中的exceptionHandler才能捕获这个异常，具体代码如下</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">context<span class="variable">.exceptionHandler</span> = ^(<span class="built_in">JSContext</span> *con, <span class="built_in">JSValue</span> *exception) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, exception);</span><br><span class="line">        <span class="built_in">NSAssert</span>(<span class="literal">NO</span>, <span class="string">@"js exception: %@"</span>, exception);</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h1 id="使用#pragma来抑制warning">使用#pragma来抑制warning</h1><p>详细的介绍可以看参考<a href="http://nshipster.cn/clang-diagnostics/" target="_blank" rel="external">Matt Thomson写的一篇关于clang diagnostics的文章</a>，里面提供了一个<a href="http://fuckingclangwarnings.com/" target="_blank" rel="external">网站</a>详细地记录了抑制各种warning的写法。</p>
<h1 id="使用宏来预定义IMP函数">使用宏来预定义IMP函数</h1><p>由于要替换原有的函数实现，所以要预先定义好各种返回类型的IMP函数。如果全部写出来的话，将会耗费大量篇幅来写差不多的函数实现，这里作者使用了宏来进行替换，具体代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="preprocessor">#<span class="keyword">define</span> JPMETHOD_IMPLEMENTATION(_type, _typeString, _typeSelector) \</span><br><span class="line">    JPMETHOD_IMPLEMENTATION_RET(_type, _typeString, return [[ret toObject] _typeSelector]) \</span><br><span class="line"></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> JPMETHOD_IMPLEMENTATION_RET(_type, _typeString, _ret) \</span><br><span class="line">static _type JPMETHOD_IMPLEMENTATION_NAME(_typeString) (id slf, SEL selector) &#123;    \</span><br><span class="line">    JSValue *fun = getJSFunctionInObjectHierachy(slf, selector);    \</span><br><span class="line">    JSValue *ret = [fun callWithArguments:_TMPInvocationArguments];  \</span><br><span class="line">    _ret;    \</span><br><span class="line">&#125;   \</span><br><span class="line"></span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> JPMETHOD_IMPLEMENTATION_NAME(_typeString) JPMethodImplement_##_typeString</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="preprocessor">#<span class="keyword">pragma</span> clang diagnostic ignored "-Wunused-variable"</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> JPMETHOD_RET_ID \</span><br><span class="line">    id obj = formatJSToOC(ret); \</span><br><span class="line">    <span class="keyword">if</span> ([obj isKindOfClass:[NSNull class]]) return nil;  \</span><br><span class="line">    return obj;</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">#<span class="keyword">define</span> JPMETHOD_RET_STRUCT(_methodName)    \</span><br><span class="line">    id dict = formatJSToOC(ret);   \</span><br><span class="line">    return _methodName(dict);</span></span><br><span class="line"></span><br><span class="line">JPMETHOD_IMPLEMENTATION_RET(<span class="keyword">void</span>, v, nil)</span><br><span class="line">JPMETHOD_IMPLEMENTATION_RET(id, id, JPMETHOD_RET_ID)</span><br><span class="line">JPMETHOD_IMPLEMENTATION_RET(CGRect, rect, JPMETHOD_RET_STRUCT(dictToRect))</span><br><span class="line">JPMETHOD_IMPLEMENTATION_RET(CGSize, size, JPMETHOD_RET_STRUCT(dictToSize))</span><br><span class="line">JPMETHOD_IMPLEMENTATION_RET(CGPoint, point, JPMETHOD_RET_STRUCT(dictToPoint))</span><br><span class="line">JPMETHOD_IMPLEMENTATION_RET(NSRange, range, JPMETHOD_RET_STRUCT(dictToRange))</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">char</span>, c, charValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">unsigned</span> <span class="keyword">char</span>, C, unsignedCharValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">short</span>, s, shortValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">unsigned</span> <span class="keyword">short</span>, S, unsignedShortValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">int</span>, i, intValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">unsigned</span> <span class="keyword">int</span>, I, unsignedIntValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">long</span>, l, longValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">unsigned</span> <span class="keyword">long</span>, L, unsignedLongValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">long</span> <span class="keyword">long</span>, q, longLongValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span>, Q, unsignedLongLongValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">float</span>, f, floatValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(<span class="keyword">double</span>, d, doubleValue)</span><br><span class="line">JPMETHOD_IMPLEMENTATION(BOOL, B, boolValue)</span><br></pre></td></tr></table></figure>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/JSPatch/">JSPatch</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-JSPatch源码剖析计划" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/15/JSPatch源码剖析计划/" class="article-date">
  	<time datetime="2015-06-15T13:57:35.000Z" itemprop="datePublished">2015-06-15</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/15/JSPatch源码剖析计划/">JSPatch源码剖析计划</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="缘起">缘起</h1><p>来实习之前的第一个星期，导师津神就给我布置了一个任务，让我研究一下wax和iOS热部署，希望我能在实习的过程中把这个搞定并应用到项目的下一个版本之中。导师出到声，我赶紧上github把wax clone下来。看了下ReadME大致了解了wax的情况:</p>
<ol>
<li>项目是lua写的，意味我又得学一门新语言了</li>
<li>wax年久失修，多年之前作者便不作更新，并留下这样一句话就离开了iOS界</li>
</ol>
<blockquote>
<p>I am no longer developing iOS applications and don’t have time to work on Wax. If you would like to take over as the maintainer, fork Wax and maintain it there. If your fork becomes popular I will add a link to it to this Readme.</p>
</blockquote>
<p>这明显是财产自由了才跑了吧- -||。</p>
<p>四五年前就不更新意味着wax并不支持block和arc等新技术（其实也不算新了），我顿时感觉坑有点大- -。这时候bang神带着他的JSPatch出现，拯救了我！</p>
<h1 id="JSPatch">JSPatch</h1><blockquote>
<p>只需在项目中引入极小的引擎，就可以使用JavaScript调用任何Objective-C的原生接口，获得脚本语言的能力：动态更新APP，替换项目原生代码修复bug。<br>—-JSPatch by bang590</p>
</blockquote>
<p>以下是bang神写的两篇关于JSPatch的介绍以及原理</p>
<p><a href="http://blog.cnbang.net/works/2767/" target="_blank" rel="external">JSPatch – 动态更新iOS APP</a></p>
<p><a href="http://blog.cnbang.net/tech/2808/" target="_blank" rel="external">JSPatch实现原理详解</a></p>
<p>JSPatch当中的核心技术就是JSBinding以及Objective-C runtime技术，对于我这种JS和runtime都是半桶水的人来说理解起来还是有点吃力的。但是伟大的Linux作者林纳斯曾经说过“RTFSC”！为了深入学习JSPatch，就得深入到源代码之中。接下来的几篇日志中，我将会分析JSPatch的源代码和详细的思路。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS开发/">iOS开发</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
    <article id="post-My-first-post" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/06/14/My-first-post/" class="article-date">
  	<time datetime="2015-06-14T03:26:06.000Z" itemprop="datePublished">2015-06-14</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2015/06/14/My-first-post/">第一篇博客</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="缘起">缘起</h2><p>其实很早之前就听说过用github page加个模板引擎就可以搭建一个简单的博客，自己作为一个程序员也想要一个属于自己的技术博客很久了，今天耗费了一点时间终于能够得偿所愿。</p>
<p>不过拖了这么长时间才搭建起来也确实是有自己的原因，我一直以来对自己的文笔是不大有信心的。回想起以前初中、高中每当要语文考试的时候，我都要花一个周末的时间（语文考试一般是周一第一门）来背诵语文作文，那段日子真的是不堪回首。读研之后自己也开始记录一些技术方面的文字，这些文字现在都静静地躺在印象笔记里，统计了一下不知不觉已经有549篇笔记了。以后估计会稍微整理一下有用的笔记出来分享到博客当中。</p>
<h2 id="这个博客要写些什么内容">这个博客要写些什么内容</h2><p>前期还是会多写些关于iOS技术类的文章，总结一些开发时遇到的问题，在微信实习的经历和感悟。后期等博客写熟练，磨练出自己的文笔和有更多的生活历练之后会尝试写一些关于人文类的、生活体验类的文章。</p>
<h2 id="最后">最后</h2><p>最后想对自己提几个要求</p>
<p>1、希望自己能够在这个博客里多思考多总结，而不要想都不想先转载，转载是别人的，思考过后才是你的。</p>
<p>2、写博客难在坚持，千万不能半途而废，贵在积累。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/小记/">小记</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>






  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2015 Albert43
    	</div>
      	<div class="footer-right">
      	 	Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>, Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> 
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js" type="text/javascript"></script>
<script src="/js/main.js" type="text/javascript"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>